=========================================================================================================
Tags: AMZ, GOG

=========================================================================================================
(AMZ)
3. Longest Substring Without Repeating Characters

- Queue + Set O(n)

=========================================================================================================
(AMZ, GOG)
4. Median of Two Sorted Arrays (*)

- Binary Search O(log(m + n)) (https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2481/Share-my-O(log(min(mn)))-solution-with-explanation)
- Recursion O(log(m + n)) (https://leetcode.com/problems/median-of-two-sorted-arrays/discuss/2496/Concise-JAVA-solution-based-on-Binary-Search)
- Divide & Conquer

=========================================================================================================
(AMZ, GOG)
10. Regular Expression Matching (*)

- Recursion (https://leetcode.com/problems/regular-expression-matching/discuss/5847/Evolve-from-brute-force-to-dp)
- Backtracking (https://leetcode.com/problems/regular-expression-matching/discuss/5847/Evolve-from-brute-force-to-dp)
- DP (https://leetcode.com/problems/regular-expression-matching/discuss/5651/Easy-DP-Java-Solution-with-detailed-Explanation)

=========================================================================================================
(AMZ)
11. Container With Most Water

- Brute Force O(n * n)
- Recursion O(n * n)
- Two point scan O(n) (https://leetcode.com/problems/container-with-most-water/discuss/6091/Easy-Concise-Java-O(N)-Solution-with-Proof-and-Explanation)

=========================================================================================================
(GOG)
17. Letter Combinations of a Phone Number

- Brute Force (for loop) O(3 ^ n)
- Recursion O(3 ^ n)
- Divide & Conquer O(3 ^ n)
- Queue O(3 ^ n) (https://leetcode.com/problems/letter-combinations-of-a-phone-number/discuss/8064/My-java-solution-with-FIFO-queue)

=========================================================================================================
(GOG)
20. Valid Parentheses

- Stack O(n) (https://leetcode.com/problems/valid-parentheses/discuss/9178/Short-java-solution)

=========================================================================================================
(GOG)
22. Generate Parentheses (*)

- Brute Force (list all possible combinations)
- Recursion (get all substrings with valid parentheses) (https://leetcode.com/problems/generate-parentheses/discuss/10337/My-accepted-JAVA-solution)
- Backtracking (https://leetcode.com/problems/generate-parentheses/discuss/10100/Easy-to-understand-Java-backtracking-solution)

=========================================================================================================
(AMZ, GOG)
23. Merge k Sorted Lists (*)

- Divide & Conquer O(n * logn)
- Heap/Priority Queue O(n * logn)
- Recursion O(n * n)
- Sorting O(n * logn)

=========================================================================================================
(GOG)
31. Next Permutation (*)

- Math (find the digit need to change that digits on its right have digit bigger than it)

=========================================================================================================
(AMZ)
32. Longest Valid Parentheses (*)

- Stack O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack)
- Recursion O(2^n)
- DP O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14133/My-DP-O(n)-solution-without-using-stack)

=========================================================================================================
(AMZ, GOG)
42. Trapping Rain Water (*)

- Recursion O(n)
- DP O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Two Pointers O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Stack O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)

=========================================================================================================
(GOG)
44. Wildcard Matching (*)

- Recursion (Time Out)
- DP (https://leetcode.com/problems/wildcard-matching/discuss/17812/My-java-DP-solution-using-2D-table)
- Two Pointers / Greedy (https://leetcode.com/problems/wildcard-matching/discuss/17810/Linear-runtime-and-constant-space-solution)

=========================================================================================================
(AMZ)
49. Group Anagrams

- Union Find O(n * n)
- HashTable/HashMap O(n)

=========================================================================================================
(GOG)
50. Pow(x, n) (*)

- Brute Force O(n)
- Recursion O(n)
- Divide & Conquer O(logn) (https://leetcode.com/problems/powx-n/discuss/19546/Short-and-easy-to-understand-solution)
- Bit Operation O(n)

=========================================================================================================
(GOG)
54. Spiral Matrix

- Traverse node in four directions

=========================================================================================================
(GOG)
56. Merge Intervals (*)

- Sort + Greedy O(n * logn) (https://leetcode.com/problems/merge-intervals/discuss/21222/A-simple-Java-solution)
- Recursion O(n * n)
- Recursion + Binary Search O(n * logn)
- Divide & Conquer O(n * logn)
- Interval/Range Tree (for streaming input) O(n * logn) (https://leetcode.com/problems/merge-intervals/discuss/21451/Share-my-BST-interval-tree-solution-C%2B%2B-No-sorting!)

=========================================================================================================
(GOG)
57. Insert Interval (*)

- Brute Force O(n)
- Binary Search (start node + end node) O(logn)
- Interval Tree O(n * logn)

=========================================================================================================
(GOG)
66. Plus One

- Math O(n)

=========================================================================================================
(AMZ)
72. Edit Distance

- Recursion (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)
- DP (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)

=========================================================================================================
(AMZ)
84. Largest Rectangle in Histogram (*)

- Brute Force
Scan from left to right to find the area for each Histogram.
Time: O(n * n)

- Binary Search Tree
We can think of the probelm is to solve that find the range of nodes that is larger than the current height
and calculate the area from the range. e.g., for node 3, height is 5, and the nodes is higher than node 3 are
node 4 and 5, thus the area is 5 * 2 = 10.
We can build a binary search tree storing node numbers, find a range of nodes that is larger than current node
and calculate the area and find the maximum.
Time: O (n * logn)

- Divide & Conquer (https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/)
We can use Divide and Conquer to solve this in O(n * Logn) time. The idea is to find the minimum value in the given array. Once we have index of the minimum value, the max area is maximum of following three values.
a) Maximum area in left side of minimum value (Not including the min value)
b) Maximum area in right side of minimum value (Not including the min value)
c) Number of bars multiplied by minimum value.
The areas in left and right of minimum value bar can be calculated recursively. If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). In worst case, we always have (n-1) elements in one side and 0 elements in other side and if the finding minimum takes O(n) time, we get the recurrence similar to worst case of Quick Sort.

- Stack (https://www.geeksforgeeks.org/largest-rectangle-under-histogram/)
We can use stack to calculate the area for each histogram in O(n).
We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.
1) Create an empty stack.
2) Start from first bar, and do following for every bar ‘hist[i]’ where ‘i’ varies from 0 to n-1.
……a) If stack is empty or hist[i] is higher than the bar at top of stack, then push ‘i’ to stack.
……b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).
3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.

=========================================================================================================
(AMZ)
102. Binary Tree Level Order Traversal

- BFS
- Queue

=========================================================================================================
(AMZ)
121. Best Time to Buy and Sell Stock

- Brute Force O(n * n)
- Recursion O(n * n)
- DP O(n)
- One time scan with Min and Max O(n)
- Sort + Two pointers O(n * logn)

=========================================================================================================
(AMZ)
126. Word Ladder II (*)

- DFS
- BFS (Queue)
- Backtracking (DFS + Pruning)

=========================================================================================================
(AMZ)
127. Word Ladder

- DFS
- BFS (Queue) (The best solution) (https://zxi.mytechroad.com/blog/searching/127-word-ladder/)
- Backtracking (DFS + Pruning)

=========================================================================================================
(GOG)
128. Longest Consecutive Sequence (*)

- HashMap O(n) (https://leetcode.com/problems/longest-consecutive-sequence/discuss/41055/My-really-simple-Java-O(n)-solution-Accepted)
- HashSet O(n) (https://leetcode.com/problems/longest-consecutive-sequence/discuss/41057/Simple-O(n)-with-Explanation-Just-walk-each-streak)
- Space for time O(N) (N = Integer.MAX)
- Union & Find O(n * logn) (https://leetcode.com/problems/longest-consecutive-sequence/discuss/41062/My-Java-Solution-using-UnionFound)
- Range Tree O(n * logn)
- Sort O(n * logn)

=========================================================================================================
(GOG)
133. Clone Graph

- DFS copy
- BFS copy (Queue + HashSet/HashMap)

=========================================================================================================
(AMZ)
138. Copy List with Random Pointer

- Hash Table/Map (https://blog.csdn.net/liuchonge/article/details/74858192)
- Interweave (http://fisherlei.blogspot.com/2013/11/leetcode-copy-list-with-random-pointer.html)

=========================================================================================================
(AMZ, GOG)
139. Word Break (*)

- DFS + Trie
- Backtracking + Trie
- Recursion O(n * n)
- DP O(n * n)

=========================================================================================================
(GOG)
140. Word Break II (*)

- Trie + DFS/BFS (search all possibilities) (https://leetcode.com/problems/word-break-ii/discuss/44167/My-concise-JAVA-solution-based-on-memorized-DFS)
- Trie + Backtracking
- Trie + Recursion
- DP (https://leetcode.com/problems/word-break-ii/discuss/44353/My-DP-solution-in-JAVA)

=========================================================================================================
(AMZ)
141. Linked List Cycle

- Set O(n)
- Two Pointers (Fast + Slow) O(n)

=========================================================================================================
(AMZ, GOG)
146. LRU Cache (*)

- HashMap + Queue
- HashMap + Double Linked List (https://leetcode.com/problems/lru-cache/discuss/45911/Java-Hashtable-%2B-Double-linked-list-(with-a-touch-of-pseudo-nodes))
(https://www.cnblogs.com/yrbbest/p/4489577.html)

=========================================================================================================
(AMZ, GOG)
155. Min Stack (*)

- Stack + Heap
- Pure Stack (https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack)
- Two Stacks (https://leetcode.com/problems/min-stack/discuss/49030/Simple-Java-solution-using-two-build-in-stacks)
- Pure Linked List (https://leetcode.com/problems/min-stack/discuss/49010/Clean-6ms-Java-solution)
- Stack + Linked List

=========================================================================================================
(AMZ)
160. Intersection of Two Linked Lists (*)

- Set
- Get Linked List length first and run two pointers at the same position (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49792/Concise-JAVA-solution-O(1)-memory-O(n)-time)
- Two pointers (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!)

=========================================================================================================
(GOG)
162. Find Peak Element (*)

- Brute Force O(n)
- Binary Search O(logn) (https://leetcode.com/problems/find-peak-element/discuss/50239/Java-solution-and-explanation-using-invariants)
(https://leetcode.com/problems/find-peak-element/discuss/192138/A-simple-reason-why-binary-search-works)

=========================================================================================================
(GOG)
166. Fraction to Recurring Decimal (*)

- Math (https://leetcode.com/problems/fraction-to-recurring-decimal/discuss/51106/My-clean-Java-solution)

=========================================================================================================
(AMZ)
167. Two Sum II - Input array is sorted

- Recursion O(n * n)
- Two Pointers O(n)
- Binary Search O(n * logn)

=========================================================================================================
(GOG)
173. Binary Search Tree Iterator (*)

- Array (Time: O(1), Space: O(n))
- Stack (Time: O(h), Space: O(h)) (https://leetcode.com/problems/binary-search-tree-iterator/discuss/52525/My-solutions-in-3-languages-with-Stack)
(https://leetcode.com/problems/binary-search-tree-iterator/discuss/52526/Ideal-Solution-using-Stack-(Java))
- Node with next smallest number (Time: O(1), Space: O(n))

=========================================================================================================
(AMZ)
189. Rotate Array (*)

- Reverse Array (https://leetcode.com/problems/rotate-array/discuss/54250/Easy-to-read-Java-solution)
- New Array (https://leetcode.com/problems/rotate-array/discuss/54289/My-three-way-to-solve-this-problem-the-first-way-is-interesting(JAVA))
- Replace 1 by 1 (https://leetcode.com/problems/rotate-array/discuss/54490/*Java*-O(1)-space-O(n)-time-with-detailed-explanations)

=========================================================================================================
(AMZ)
199. Binary Tree Right Side View (*)

- BFS (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56076/Reverse-Level-Order-Traversal-java)
- DFS (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56167/DFS-solution-better-than-90-solutions!)
- Recursion (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56012/My-simple-accepted-solution(JAVA))
- Divide & Conquer (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56062/Java-Solution-using-Divide-and-Conquer)

=========================================================================================================
(AMZ, GOG)
200. Number of Islands (*)

- DFS O(n * m) (https://leetcode.com/problems/number-of-islands/discuss/56359/Very-concise-Java-AC-solution)
- BFS O(n * m) (https://leetcode.com/problems/number-of-islands/discuss/56338/Java-DFS-and-BFS-solution)
- Union Find O(n * m * log(n * m)) (https://leetcode.com/problems/number-of-islands/discuss/56354/1D-Union-Find-Java-solution-easily-generalized-to-other-problems)
- Recursion (by row/column) O(n * m)
- Divide & Conquer O(n * m)

=========================================================================================================
(AMZ)
204. Count Primes

- Math (https://leetcode.com/problems/count-primes/discuss/57588/My-simple-Java-solution)

=========================================================================================================
(AMZ)
206. Reverse Linked List

- Recursion (https://leetcode.com/problems/reverse-linked-list/discuss/58156/My-Java-recursive-solution)
- Divide & Conquer
- Linked List operation (in-place) (https://leetcode.com/problems/reverse-linked-list/discuss/58125/In-place-iterative-and-recursive-Java-solution)

=========================================================================================================
(GOG)
208. Implement Trie (Prefix Tree) (*)

- Trie (use Tree + Array to implement)
(https://leetcode.com/problems/implement-trie-prefix-tree/discuss/58832/AC-JAVA-solution-simple-using-single-array)
- Trie (use Tree + HashMap to implement)
(https://leetcode.com/problems/implement-trie-prefix-tree/discuss/58868/Implement-Trie-(Prefix-Tree)-C%2B%2B-Clean-Code-(array-or-map))
(https://leetcode.com/problems/implement-trie-prefix-tree/discuss/58986/Concise-O(1)-JAVA-solution-based-on-HashMap)

=========================================================================================================
(AMZ)
211. Add and Search Word - Data structure design (*)

- HashSet/HashMap
- Trie
- Array/List (Sorting & Backtracking)

=========================================================================================================
(GOG)
212. Word Search II (*)

- DFS/Backtracking
(https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00))
(https://leetcode.com/problems/word-search-ii/discuss/59784/My-simple-and-clean-Java-code-using-DFS-and-Trie)
(https://leetcode.com/problems/word-search-ii/discuss/156559/Java-(40ms)-Solution-with-Complexity-Analysis)
- BFS
- Sort + Trie (avoid duplicated search cases)
(https://leetcode.com/problems/word-search-ii/discuss/59780/Java-15ms-Easiest-Solution-(100.00))
(https://leetcode.com/problems/word-search-ii/discuss/59784/My-simple-and-clean-Java-code-using-DFS-and-Trie)
(https://leetcode.com/problems/word-search-ii/discuss/156559/Java-(40ms)-Solution-with-Complexity-Analysis)
- Use Shortest Distance for Pruning (reduce search space)

=========================================================================================================
(GOG)
214. Shortest Palindrome (*)

- Backtracking/Recursion (start from mid of string and to the most left) O(n * n)
- Brute Force (try extending from 0 - n characters) O(n * n)
(https://leetcode.com/problems/shortest-palindrome/discuss/60099/AC-in-288-ms-simple-brute-force)
- Stack O(n * n)
- KMP O(n)
(https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation)
(https://leetcode.com/problems/shortest-palindrome/discuss/60141/C%2B%2B-8-ms-KMP-based-O(n)-time-and-O(n)-memory-solution)
- Rabin-Karp Rolling Hash O(n)
(https://leetcode.com/problems/shortest-palindrome/discuss/60153/8-line-O(n)-method-using-Rabin-Karp-rolling-hash)

=========================================================================================================
(AMZ)
215. Kth Largest Element in an Array (*)

- Sort O(n * logn) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained)
- Priority Queue O(n * logk) /Heap O(n * logn) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained)
- Quick Select O(n * logn) (https://en.wikipedia.org/wiki/Quickselect) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60312/AC-Clean-QuickSelect-Java-solution-avg.-O(n)-time)
- Recursion O(n * n)

=========================================================================================================
(AMZ, GOG)
218. The Skyline Problem (*)

- Heap O(n * logn) - (Naturally Thinking / Data Structure in Common Strategy)
(sweep line: https://zxi.mytechroad.com/blog/tree/leetcode-218-the-skyline-problem/)
- Recursion O(n * n) - (Recursion in Common Strategy)
- Divide & Conquer O(n * logn) - (Divide & Conquer in Common Strategy)
(https://www.geeksforgeeks.org/the-skyline-problem-using-divide-and-conquer-algorithm/)
(https://leetcode.com/problems/the-skyline-problem/discuss/61281/Java-divide-and-conquer-solution-beats-96)
- Tree, Segment Tree O(n * logn) - (Tree in Common Strategy)
(https://leetcode.com/problems/the-skyline-problem/discuss/61313/A-segment-tree-solution)
- Binary Indexed Tree(BIT)/Fenwick Tree O(n * logn) - (Data Structure in Common Strategy)
(https://leetcode.com/problems/the-skyline-problem/discuss/61198/My-O(nlogn)-solution-using-Binary-Indexed-Tree(BIT)Fenwick-Tree)

=========================================================================================================
(GOG)
224. Basic Calculator (*)

- Divide & Conquer + Stack
- Recursion + Stack

=========================================================================================================
(GOG)
228. Summary Ranges (*)

- Sort + Scan
- Recursion
- Divide & Conquer
- Segment Tree

=========================================================================================================
(GOG)
230. Kth Smallest Element in a BST (*)

- Tree Traverse O(n)
- Tree Traverse + Array O(n) (Query time: O(1))
- Recursion/Divide & Conquer O(n)
- Design/Change Tree Node Structure O(n) (Query time: O(logn))

=========================================================================================================
(GOG)
231. Power of Two (*)

- Math O(1)
(https://leetcode.com/problems/power-of-two/discuss/63974/Using-nand(n-1)-trick)
(https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math)
- Division O(logn) (https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math)
- Recursion O(logn) (https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math)
- Bit Manipulation O(logn)
(https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math)
(https://leetcode.com/problems/power-of-two/discuss/63972/One-line-java-solution-using-bitCount)
- HashSet (for frequent numbers) O(1) (https://leetcode.com/problems/power-of-two/discuss/63966/4-different-ways-to-solve-Iterative-Recursive-Bit-operation-Math)

=========================================================================================================
(AMZ)
234. Palindrome Linked List

- Stack
- Array
- Recursion
- Two Pointers (https://leetcode.com/problems/palindrome-linked-list/discuss/64501/Java-easy-to-understand)

=========================================================================================================
(AMZ)
235. Lowest Common Ancestor of a Binary Search Tree

- Iteratvie O(logn)
- Recursion

=========================================================================================================
(AMZ)
236. Lowest Common Ancestor of a Binary Tree

- DFS/BFS to find the path, then find common ancester (https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65335/Java-iterative-and-recursive-solutions.)
- Recursion (https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65225/4-lines-C%2B%2BJavaPythonRuby)

=========================================================================================================
(AMZ)
238. Product of Array Except Self (*)

- Math (https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space)
(https://leetcode.com/problems/product-of-array-except-self/discuss/65632/My-solution-beats-100-java-solutions)
(https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space/265861)

=========================================================================================================
(AMZ, GOG)
239. Sliding Window Maximum (*)

- Recursion O(n * k)
- Heap O(n * logk) (https://leetcode.com/problems/sliding-window-maximum/discuss/65936/My-Java-Solution-Using-PriorityQueue)
- Deque O(n) (https://leetcode.com/problems/sliding-window-maximum/discuss/65884/Java-O(n)-solution-using-deque-with-explanation)
- Two Pointers, record the highest and the second highest point O(n)
- Math O(n) (https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array)

=========================================================================================================
(AMZ, GOG)
240. Search a 2D Matrix II (*)

- HashMap O(m * n)
- DFS/BFS/Backtracking O(m * n)
- Iterative O(m * n)
- Divide & Conquer (https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66147/*Java*-an-easy-to-understand-divide-and-conquer-method)
- Two Pointers/BST O(m + n) (https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66140/My-concise-O(m%2Bn)-Java-solution)

=========================================================================================================
(AMZ)
242. Valid Anagram

- HashMap/HashTable O(n) (https://leetcode.com/problems/valid-anagram/discuss/66533/Java-solution-HashMap-Unicode-Follow-up)
- Sort O(n * logn) (https://leetcode.com/problems/valid-anagram/discuss/66651/Java-solution-using-sort)
- Array O(n) (https://leetcode.com/problems/valid-anagram/discuss/66484/Accepted-Java-O(n)-solution-in-5-lines)

=========================================================================================================
(GOG)
257. Binary Tree Paths (*)

- Recursion/Divide & Conquer (https://leetcode.com/problems/binary-tree-paths/discuss/68278/My-Java-solution-in-DFS-BFS-recursion)
- DFS (https://leetcode.com/problems/binary-tree-paths/discuss/68278/My-Java-solution-in-DFS-BFS-recursion)
- BFS (https://leetcode.com/problems/binary-tree-paths/discuss/68278/My-Java-solution-in-DFS-BFS-recursion)

=========================================================================================================
(GOG)
274. H-Index (*)

- Sort + Brute Force O(n * logn)
- Sort + Binary Search + Pruning O(n * logn) (https://leetcode.com/problems/h-index/discuss/70990/Java-AC-solution-by-Binary-Search)
- Recursion O(n * logn)
- Bucket Sort O(n) (https://leetcode.com/problems/h-index/discuss/70768/Java-bucket-sort-O(n)-solution-with-detail-explanation)

=========================================================================================================
(GOG)
279. Perfect Squares (*)

- Brute Force
- Recursion
- DP O(n) (https://leetcode.com/problems/perfect-squares/discuss/71488/Summary-of-4-different-solutions-(BFS-DP-static-DP-and-mathematics))
- BFS (https://leetcode.com/problems/perfect-squares/discuss/71488/Summary-of-4-different-solutions-(BFS-DP-static-DP-and-mathematics))

=========================================================================================================
(GOG)
282. Expression Add Operators (*)

- Brute Force (try all possibilities to fill in operators) O(4 ^ n)
- Recursion/DFS O(4 ^ n)
(https://leetcode.com/problems/expression-add-operators/discuss/71895/Java-Standard-Backtrace-AC-Solutoin-short-and-clear)
(https://leetcode.com/problems/expression-add-operators/discuss/71897/Java-AC-solution-19ms-beat-100.00.)

=========================================================================================================
(GOG)
284. Peeking Iterator (*)

- Design
(Think of "looking ahead". You want to cache the next element.)
(https://github.com/google/guava/blob/703ef758b8621cfbab16814f01ddcc5324bdea33/guava-gwt/src-super/com/google/common/collect/super/com/google/common/collect/Iterators.java#L1125)

=========================================================================================================
(GOG)
289. Game of Life (*)

- Array (In-place change)
(https://leetcode.com/problems/game-of-life/discuss/73223/Easiest-JAVA-solution-with-explanation)
(https://leetcode.com/problems/game-of-life/discuss/73366/Clean-O(1)-space-O(mn)-time-Java-Solution)

=========================================================================================================
(GOG)
295. Find Median from Data Stream (*)

- Binary Search Tree with children count (Insert: O(logn), Query: O(logn))
- LinkedList/DoubleLinkedList/Array (Insert: O(n), Query: O(1))
- Segment Tree/Range Tree with children count (Insert: O(logn), Query: O(logn))
- Bucket Sort (Insert: O(n), Query: O(1))
- Heap (Insert: O(logn), Query: O(1))
(https://leetcode.com/problems/find-median-from-data-stream/discuss/74047/JavaPython-two-heap-solution-O(log-n)-add-O(1)-find)
(https://leetcode.com/problems/find-median-from-data-stream/discuss/74144/Easy-to-understand-double-heap-solution-in-Java)

=========================================================================================================
(AMZ, GOG)
297. Serialize and Deserialize Binary Tree (*)

- Serialize as array - [1,2,3,null,null,4,5]
- Serialize as JSON with ID - [id:1,val:1,left:2,right:3],[id:2,val:2],[id:3,left:4,right:5],...
- Serialize as String - 1{2}{3{4}{5}}/1(2)(3(4(5))
- Pre-order & Queue (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74253/Easy-to-understand-Java-Solution)
- BFS & Queue (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74264/Short-and-straight-forward-BFS-Java-code-with-a-queue)
- DFS & BFS (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74260/Recursive-DFS-Iterative-DFS-and-BFS)
- Recusion (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74417/Short-and-clear-recursive-Java-solution)

=========================================================================================================
(GOG)
309. Best Time to Buy and Sell Stock with Cooldown (*)

- Brute Force O(2 ^ n)
- Divide & Conquer/Recursion O(n * n)
- DP O(n * n)
(https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75927/Share-my-thinking-process)
(https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/discuss/75931/Easiest-JAVA-solution-with-explanations)

=========================================================================================================
(GOG)
310. Minimum Height Trees (*)

- BFS/Minimum Path
(https://leetcode.com/problems/minimum-height-trees/discuss/76055/Share-some-thoughts)
(https://leetcode.com/problems/minimum-height-trees/discuss/76052/Two-O(n)-solutions)
- DFS

=========================================================================================================
(GOG)
312. Burst Balloons (*)

- Brute Force O(n!) (Permutation Problem)
- Divide & Conquer O(n * n * n)
(https://leetcode.com/problems/burst-balloons/discuss/76228/Share-some-analysis-and-explanations)
(https://leetcode.com/problems/burst-balloons/discuss/76245/Easiest-Java-Solution)
- DP (Cache/Memorization) O(n * n * n)
(https://leetcode.com/problems/burst-balloons/discuss/76228/Share-some-analysis-and-explanations)
(https://leetcode.com/problems/burst-balloons/discuss/76245/Easiest-Java-Solution)

=========================================================================================================
(GOG)
313. Super Ugly Number (*)

- Burte Force
- Math O(k * n) (New ugly number is generated by multiplying a prime with previous generated ugly number. One catch is need to remove duplicate)
(https://leetcode.com/problems/super-ugly-number/discuss/76291/Java-three-methods-23ms-36-ms-58ms(with-heap)-performance-explained)
- DP O(k * n)
(https://leetcode.com/problems/super-ugly-number/discuss/169815/Python-DP-solution-beats-93.7-extremely-detailed-explanation)
- Heap
(https://leetcode.com/problems/super-ugly-number/discuss/76291/Java-three-methods-23ms-36-ms-58ms(with-heap)-performance-explained)

=========================================================================================================
(GOG)
315. Count of Smaller Numbers After Self (*)

- Brute Force O(n * n)
- Recursion O(n * n)
- DP O(n * n)
- Sort + Map O(n * n)
- BST O(n * logn) (https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76580/9ms-short-Java-BST-solution-get-answer-when-building-BST)
- Divide & Conquer/Merge Sort O(n * logn) (https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76584/Mergesort-solution)
- Binary Index Tree O(n * logn) (https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76611/Short-Java-Binary-Index-Tree-BEAT-97.33-With-Detailed-Explanation)
- Segment Tree O(n * logn) (https://leetcode.com/problems/count-of-smaller-numbers-after-self/discuss/76657/3-ways-(Segment-Tree-Binary-Indexed-Tree-Binary-Search-Tree)-clean-python-code)

=========================================================================================================
(GOG)
316. Remove Duplicate Letters (*)

- Brute Force O(a * b * c * ...)
- Greedy + Sort + Map O(n * logn) (Arrange letters are unique first, then greedyly decide the position of duplicated letters from small to big letters)
- Greedy
(https://leetcode.com/problems/remove-duplicate-letters/discuss/76768/A-short-O(n)-recursive-greedy-solution)
(https://leetcode.com/problems/remove-duplicate-letters/discuss/76766/Easy-to-understand-iterative-Java-solution)
- Greedy + Stack O(n) (https://leetcode.com/problems/remove-duplicate-letters/discuss/76762/Java-O(n)-solution-using-stack-with-detail-explanation)

=========================================================================================================
(GOG)
318. Maximum Product of Word Lengths (*)

- Brute Force O(n * n)
- Recursion + Pruning O(n * n)
- Bit Operation + Greedy O(n * n) (use 26 bits to represent if each letter is part of the string) (starts from longest string to shortest)
- Bit Operation O(n * n)
(https://leetcode.com/problems/maximum-product-of-word-lengths/discuss/76959/JAVA-Easy-Version-To-Understand!!!!!!!!!!!!!!!!!)

=========================================================================================================
(GOG)
321. Create Maximum Number (*)

- Brute Force O(n * n) (pick 5 numbers from the arrays together)
(https://leetcode.com/problems/create-maximum-number/discuss/77285/Share-my-greedy-solution)
(https://leetcode.com/problems/create-maximum-number/discuss/77287/C%2B%2B-16ms-FASTEST-beats-97.)
- Greedy + Sort (Heap) + LinkedList O(n * logn) (use Greedy algorithm as we should pick first n biggest number from both list together)

=========================================================================================================
(GOG)
324. Wiggle Sort II (*)

- Sort O(n * logn) (in sorted array, first half in odd position, the other half in even postion)
(https://leetcode.com/problems/wiggle-sort-ii/discuss/77681/O(n)-time-O(1)-space-solution-with-detail-explanations)
- Recursion O(n)

=========================================================================================================
(GOG)
326. Power of Three (*)

- Brute Force (while loop to mod 3, or check if power of 3 from smaller number to bigger)
- HashMap O(1) (remember all number power of 3)
- Math O(1)
(https://leetcode.com/problems/power-of-three/discuss/77856/1-line-java-solution-without-loop-recursion)
(https://leetcode.com/problems/power-of-three/discuss/77856/1-line-java-solution-without-loop-recursion/380103)
(https://leetcode.com/problems/power-of-three/discuss/77876/**-A-summary-of-all-solutions-(new-method-included-at-15%3A30pm-Jan-8th))

=========================================================================================================
(GOG)
327. Count of Range Sum (*)

- Brute Force O(n * n)
- Sort + Two Point Scan O(n * logn) (get sum for each position, s(i) = sum(1, i), sort from s(1) to s(n), use two point scan to find pair i, j that s(j) - s(i) in the expected range)
- Divide & Conquer/Merge Sort O(n * logn)
(https://leetcode.com/problems/count-of-range-sum/discuss/77990/Share-my-solution)
(https://leetcode.com/problems/count-of-range-sum/discuss/77991/Short-and-simple-O(n-log-n))
- Binary Indexed Tree/Binary Search
(https://leetcode.com/problems/count-of-range-sum/discuss/78006/Summary-of-the-Divide-and-Conquer-based-and-Binary-Indexed-Tree-based-solutions)
- Segment Tree/Range Tree
(https://leetcode.com/problems/count-of-range-sum/discuss/77987/Java-SegmentTree-Solution-36ms)

=========================================================================================================
(GOG)
329. Longest Increasing Path in a Matrix (*)

- Brute Force + DFS/BFS (use DFS/BFS to search path starting from each node)
- DP/Memorization + DFS/BFS
(https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78308/15ms-Concise-Java-Solution)
(https://leetcode.com/problems/longest-increasing-path-in-a-matrix/discuss/78313/Java-14ms-relative-short-and-easy-to-code-solution-with-explanation.-O(mn)-time-O(mn)-space.-DFS-%2B-DP)

=========================================================================================================
(GOG)
330. Patching Array (*)

- Greedy
(https://leetcode.com/problems/patching-array/discuss/78488/Solution-%2B-explanation)
(https://leetcode.com/problems/patching-array/discuss/78495/Share-my-thinking-process)
- Brute Force + Greedy (loop through each sum number needed, find the smallest element needs to be added) O(n ^ 3)
- Recursion + Memorization (use recursion to calculate all possible sums for a given array) (use memorization for optimization)
- BFS (use BFS to search for elements need to be added) (this is better than DFS consider pruning as we are trying to find the minimum number of elements to add)

=========================================================================================================
(GOG)
331. Verify Preorder Serialization of a Binary Tree (*)

- Math/Tree (https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/78551/7-lines-Easy-Java-Solution)
- Stack (https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/78566/Java-intuitive-22ms-solution-with-stack)
- Regex (https://leetcode.com/problems/verify-preorder-serialization-of-a-binary-tree/discuss/78640/2-lines-Java-using-Regex)

=========================================================================================================
(GOG)
332. Reconstruct Itinerary (*)

- DG(Directed graph)/DFS
(https://leetcode.com/problems/reconstruct-itinerary/discuss/78766/Share-my-solution)
(https://leetcode.com/problems/reconstruct-itinerary/discuss/78768/Short-Ruby-Python-Java-C%2B%2B)
- Tree/Graph/Linked List

=========================================================================================================
(GOG)
336. Palindrome Pairs (*)

- Brute Force O(n * n * m) (n: number of unique input words, m: max length of a word)
- Recursion + Pruning O(n * n * m) (n: number of unique input words, m: max length of a word)
- Divide & Conquer + Pruning O(n * n * m) (n: number of unique input words, m: max length of a word)
- Space & Time Trade-off O(n * m * m) (n: number of unique input words, m: max length of a word)
(https://leetcode.com/problems/palindrome-pairs/discuss/79210/The-Easy-to-unserstand-JAVA-Solution)
(https://leetcode.com/problems/palindrome-pairs/discuss/79215/Easy-to-understand-AC-C%2B%2B-solution-O(n*k2)-using-map)
(https://leetcode.com/problems/palindrome-pairs/discuss/176205/Beats-80-Trie-Java-with-Explanations)
- Trie O(n * n * m) (n: number of unique input words, m: max length of a word)
(https://leetcode.com/problems/palindrome-pairs/discuss/79195/O(n-*-k2)-java-solution-with-Trie-structure)

=========================================================================================================
(GOG)
341. Flatten Nested List Iterator (*)

- Recursion (use recursive iterator)
- Stack (DFS)
(https://leetcode.com/problems/flatten-nested-list-iterator/discuss/80147/Simple-Java-solution-using-a-stack-with-explanation)
(https://leetcode.com/problems/flatten-nested-list-iterator/discuss/80146/Real-iterator-in-Python-Java-C%2B%2B)

=========================================================================================================
(GOG)
345. Reverse Vowels of a String (*)

- Queue + Stack O(n)
- Array O(n)
- Two Pointers O(n)

=========================================================================================================
(GOG)
354. Russian Doll Envelopes (*)

- DFS/BFS (Search from each node)
- Directed Graph - find maximum path (DFS/BFS) (we can build an edge from A -> B if A < B in terms of sizes)
- Sorting
(https://leetcode.com/problems/russian-doll-envelopes/discuss/82763/Java-NLogN-Solution-with-Explanation)
(https://leetcode.com/problems/russian-doll-envelopes/discuss/82796/A-Trick-to-solve-this-problem.)
- DP
(https://leetcode.com/problems/russian-doll-envelopes/discuss/82778/Two-solutions-in-C%2B%2B-well-explained)
(https://leetcode.com/problems/russian-doll-envelopes/discuss/82810/Short-and-simple-Java-solution-(15-lines))

=========================================================================================================
(AMZ)
355. Design Twitter (*)

- HashMap/HashTable + Linked List
- OO Design + HashTable/HashMap + Heap + Linked List + HashSet/Set (https://leetcode.com/problems/design-twitter/discuss/82825/Java-OO-Design-with-most-efficient-function-getNewsFeed)
- Map + Heap (https://leetcode.com/problems/design-twitter/discuss/82837/Java-Solutions-with-Two-Maps-and-PriorityQueue)
- OO Design (https://leetcode.com/problems/design-twitter/discuss/82935/Java-OOD-solution-with-detailed-explanation)

=========================================================================================================
(GOG)
357. Count Numbers with Unique Digits (*)

- Brute Force O(10^n)
- Recursion O(10^n)
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/83054/Backtracking-solution)
- DP
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/83052/Clear-c%2B%2B-explanation-of-combinatorics-using-DP-method)
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/493812/Java-DP-Solution)
- Math
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/83041/JAVA-DP-O(1)-solution.)
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/83061/Java-O(1)-with-explanation)
(https://leetcode.com/problems/count-numbers-with-unique-digits/discuss/83094/Simple-JAVA-Solution-with-explanation.)

=========================================================================================================
(GOG)
363. Max Sum of Rectangle No Larger Than K (*)

- Brute Force O(n ^ 4)
(https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83618/2-Accepted-Java-Solution)
(https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83633/Naive-but-accepted-java-solution.)
- Backtracking
- BFS/DFS
- DP/Kadane's algorithm
(https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83599/Accepted-C%2B%2B-codes-with-explanation-and-references)
- Binary Search
(https://leetcode.com/problems/max-sum-of-rectangle-no-larger-than-k/discuss/83597/Java-Binary-Search-solution-time-complexity-min(mn)2*max(mn)*log(max(mn)))

=========================================================================================================
(GOG)
368. Largest Divisible Subset (*)

- Brute Force O(2 ^ n) (List all possible combinations)
- Sorting + Recursion O(n * n)
- Sorting + DP O(n * n)
(https://leetcode.com/problems/largest-divisible-subset/discuss/83998/C%2B%2B-Solution-with-Explanations)
- Sorting + DFS + Memorization
(https://leetcode.com/problems/largest-divisible-subset/discuss/84013/Very-short-Java-DFS-solution-using-Memoization)
(https://leetcode.com/problems/largest-divisible-subset/discuss/84081/Java-DFS-Solution-86-ms-with-explanation)
- Graph

=========================================================================================================
(GOG)
373. Find K Pairs with Smallest Sums (*)

- Brute Force O(n * n)
- Brute Force + Heap O(n * n)
- Recursion O(n * n)
- Heap O(k * logk)
(https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84551/simple-Java-O(KlogK)-solution-with-explanation)
(https://leetcode.com/problems/find-k-pairs-with-smallest-sums/discuss/84569/Java-9ms-heap-queue-solution-k-log(k))

=========================================================================================================
(GOG)
374. Guess Number Higher or Lower

- Brute Force O(n)
- Binary Search O(logn)

=========================================================================================================
(GOG)
375. Guess Number Higher or Lower II (*)

- Recursion / Minimax
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84807/Java-commented-DP-solution) - Really clear explaination!
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84764/Simple-DP-solution-with-explanation~~)
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84764/Simple-DP-solution-with-explanation~~/89362)
- DP
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84807/Java-commented-DP-solution) - Really clear explaination!
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84764/Simple-DP-solution-with-explanation~~)
(https://leetcode.com/problems/guess-number-higher-or-lower-ii/discuss/84769/Two-Python-solutions)

=========================================================================================================
(AMZ)
380. Insert Delete GetRandom O(1) (*)

- HashSet, HashMap, Array
- HashMap, List/Array (https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/85401/Java-solution-using-a-HashMap-and-an-ArrayList-along-with-a-follow-up.-(131-ms))

=========================================================================================================
(AMZ)
387. First Unique Character in a String

- HashMap O(n)
- Divide & Conquer O(n * logn)
- Recursion O(n * n)

=========================================================================================================
(AMZ)
396. Rotate Function

- Brute Force to list all possible results O(n * n)
- Math O(n) (https://leetcode.com/problems/rotate-function/discuss/87853/Java-O(n)-solution-with-explanation)

=========================================================================================================
(AMZ)
414. Third Maximum Number

- Heap/Priority Queue O(n * logn) (https://leetcode.com/problems/third-maximum-number/discuss/90190/Java-PriorityQueue-O(n)-%2B-O(1))
- Sorting O(n * logn)
- Fixed length array/Double Linked List O(n) (https://leetcode.com/problems/third-maximum-number/discuss/90202/Java-neat-and-easy-understand-solution-O(n)-time-O(1)-space)

=========================================================================================================
(AMZ)
438. Find All Anagrams in a String

- HashMap to build char-count map O(n) (Sliding Window Solution)

=========================================================================================================
(AMZ)
449. Serialize and Deserialize BST

- Recusrion: use parentheses e.g. 78(13(5)(45))(105) (Generic: applicable to all types of trees)
- BFS: 78, 13, 105, 5, 45, null, null (Generic: applicable to all types of trees)

=========================================================================================================
(AMZ)
451. Sort Characters By Frequency

- HashMap + Sort O(n)
- Array + Sort O(n) (https://leetcode.com/problems/sort-characters-by-frequency/discuss/93521/Super-simple-O(n)-Bucket-Sort-based-Java-solution-(11-ms).-No-fancy-Data-structure-needed.-Beats-96.)
- HashMap + Heap/Priority Queue O(n) (https://leetcode.com/problems/sort-characters-by-frequency/discuss/93420/Java-O(n)-Bucket-Sort-Solution-O(nlogm)-PriorityQueue-Solution-easy-to-understand)

=========================================================================================================
(AMZ)
459. Repeated Substring Pattern (*)

- Brute Force (iterate through all possible substrings, with pruning) O(n * n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94352/Java-Simple-Solution-with-Explanation)
- Two cursor O(n * n)
- Math/Smart Solution O(n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94334/Easy-python-solution-with-explaination/241011)
- KMP O(n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94340/Java-and-O(n)/113294)

=========================================================================================================
(AMZ)
460. LFU Cache (*)

- Heap/Priority Queue + HashMap O(logn)
- 3 HashMap + LinkedHashSet O(1) (https://leetcode.com/problems/lfu-cache/discuss/94521/JAVA-O(1)-very-easy-solution-using-3-HashMaps-and-LinkedHashSet)
- HashMap + DoubleLinkedList + LinkedHashSet O(1) (https://leetcode.com/problems/lfu-cache/discuss/94515/Java-O(1)-Accept-Solution-Using-HashMap-DoubleLinkedList-and-LinkedHashSet)
(https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList)
- Reb-Black Tree + HashMap O(logn) (https://leetcode.com/problems/lfu-cache/discuss/94657/Java-solutions-of-three-different-ways.-PriorityQueue-%3A-O(capacity)-TreeMap-%3A-O(log(capacity))-DoubleLinkedList-%3A-O(1))

=========================================================================================================
(AMZ)
508. Most Frequent Subtree Sum

- DFS + Heap/Priority Queue O(n * logn) (https://leetcode.com/problems/most-frequent-subtree-sum/discuss/98675/JavaC%2B%2BPython-DFS-Find-Subtree-Sum)

=========================================================================================================
(AMZ)
515. Find Largest Value in Each Tree Row

- BFS + Queue O(n) (https://leetcode.com/problems/find-largest-value-in-each-tree-row/discuss/98976/Java-BFS)
- Traverse trhough Tree/DFS (pre-order, in-order, post-order) O(n) (https://leetcode.com/problems/find-largest-value-in-each-tree-row/discuss/98971/9ms-JAVA-DFS-solution)

=========================================================================================================
(AMZ)
516. Longest Palindromic Subsequence

- Brute Force (List all substring possibilities and check) O(n * n)
- Recusion/DP O(n * n) (https://leetcode.com/problems/longest-palindromic-subsequence/discuss/99101/Straight-forward-Java-DP-solution)

=========================================================================================================
(AMZ)
517. Super Washing Machines (*)

- Math (https://blog.csdn.net/TstsUgeg/article/details/62427718) (https://leetcode.com/problems/super-washing-machines/discuss/99185/Super-Short-and-Easy-Java-O(n)-Solution)

=========================================================================================================
(AMZ)
529. Minesweeper (*)

- BFS/DFS to find adjacent blank square (https://leetcode.com/problems/minesweeper/discuss/99826/Java-Solution-DFS-%2B-BFS)
- Union-Find (Grouping) to find adjacent blank square

=========================================================================================================
(AMZ)
532. K-diff Pairs in an Array

- HashSet/HashMap (Brute Force) O(n) (https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/355150/Java-time-and-space-O(n)-solution-by-HaspMap)
- Recursion O(n) (f(n) = f(n - 1) + exist(n +/- k))
- Sorting (n * logn)
- Sorting + Two Pointers (n * logn) (https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/100104/Two-pointer-Approach)

=========================================================================================================
(AMZ)
535. Encode and Decode TinyURL (*)

- HashMap - Random String (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100268/Two-solutions-and-thoughts)
- HashMap - Hashcode String (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100270/Three-different-approaches-in-java)
(https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/254145/Java-Solutions)
- HashMap/Array - Use Index/Counter (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100276/Easy-solution-in-java-5-line-code)

=========================================================================================================
(AMZ)
537. Complex Number Multiplication

- String & Math (https://leetcode.com/problems/complex-number-multiplication/discuss/100430/Java-3-liner)

=========================================================================================================
(AMZ)
538. Convert BST to Greater Tree

- DFS/Recursion/Traverse (Traverse in decreasing order, sum up accumulatively) O(n) (https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/100506/Java-Recursive-O(n)-time)
- Iterative using Stack O(n) (https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/100516/Java-Three-O(n)-Methods%3A-Recursive-Iterative-and-Morris-Traversal)

=========================================================================================================
(AMZ)
553. Optimal Division

- Math O(n) (https://leetcode.com/problems/optimal-division/discuss/101687/Easy-to-understand-simple-O(n)-solution-with-explanation)
- Recursion O(n * n)
- DP O(n * n * n)

=========================================================================================================
(AMZ)
606. Construct String from Binary Tree

- Tree/Recursion

=========================================================================================================
(AMZ)
617. Merge Two Binary Trees

- Tree/Recursion O(n)
- Turn Tree into an array O(n)
- DFS/BFS O(n) (https://leetcode.com/problems/merge-two-binary-trees/discuss/104331/Java-One-Recursive-Solution-and-Two-Iterative-Solutions-(DFS-and-BFS)-with-Explanations)

=========================================================================================================
(AMZ)
640. Solve the Equation

- Math (https://leetcode.com/problems/solve-the-equation/discuss/105311/Concise-Java-Solution)
(https://leetcode.com/problems/solve-the-equation/discuss/306157/Java-solution-with-some-tricky-technique-for-tokenizing)

=========================================================================================================
(AMZ)
645. Set Mismatch

- HashSet + Math O(n) (https://leetcode.com/problems/set-mismatch/discuss/105528/Simple-Java-O(n)-solution-HashSet)
- Array Swap O(n) (https://leetcode.com/problems/set-mismatch/discuss/105520/Java-solution-array-swap)
- Math O(n) (https://leetcode.com/problems/set-mismatch/discuss/179810/Java-Solution-beats-100-with-O(1)-space)

=========================================================================================================
(AMZ)
646. Maximum Length of Pair Chain (*)

- Brute Force O(2 ^ n)
- Sorting + Recursion O(n * n)
- Sorting + DP O(n * n) (https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105602/easy-dp)
- Greedy Algorithm O(n * logn) (https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/105610/Java-O(nlog(n))-Time-O(1)-Space)
(https://leetcode.com/problems/maximum-length-of-pair-chain/discuss/225801/Proof-of-the-greedy-solution)

=========================================================================================================
(AMZ)
661. Image Smoother

- Array O(m * n)

=========================================================================================================
(AMZ)
662. Maximum Width of Binary Tree (*)

- BFS (Using Queue, test width level by level) (https://leetcode.com/problems/maximum-width-of-binary-tree/discuss/106645/C%2B%2BJava-*-BFSDFS3liner-Clean-Code-With-Explanation)
- DFS (https://leetcode.com/problems/maximum-width-of-binary-tree/discuss/106654/JavaC%2B%2B-Very-simple-dfs-solution)
- Array (https://leetcode.com/problems/maximum-width-of-binary-tree/discuss/106654/JavaC%2B%2B-Very-simple-dfs-solution)

=========================================================================================================
(AMZ)
675. Cut Off Trees for Golf Event (*)

- BFS/DFS with pruning
- Shortest Path (Sort known tree heights in order, traverse in a known order, add up shortest path between two points)
(Use DP/BFS for calculating shortest path between two points)
(https://leetcode.com/problems/cut-off-trees-for-golf-event/discuss/107404/Java-solution-PriorityQueue-%2B-BFS)

=========================================================================================================
(AMZ)
682. Baseball Game (*)

- Stack O(n) (https://leetcode.com/problems/baseball-game/discuss/107873/JAVA-very-concise-and-easy-to-understand-using-stack)
- List/Array O(n) (https://leetcode.com/problems/baseball-game/discuss/107860/Verbose-Java-solution-LinkedList)
- Doubly Linked List O(n)

=========================================================================================================
(AMZ)
692. Top K Frequent Words (*)

- Heap/PriorityQueue O(n * logn) (https://leetcode.com/problems/top-k-frequent-words/discuss/108346/My-simple-Java-solution-using-HashMap-and-PriorityQueue-O(nlogk)-time-and-O(n)-space)
- Map/HashTable + Sort O(n * logn)
- Recursion O(n)
- HashMap + BucketSort + Trie O(n) (https://leetcode.com/problems/top-k-frequent-words/discuss/108399/Java-O(n)-solution-using-HashMap-BucketSort-and-Trie-22ms-Beat-81)
(https://leetcode.com/problems/top-k-frequent-words/discuss/176865/13ms-Prefix-Tree-(Trie)-and-Bucket-Sort-Java-with-Explanation)

=========================================================================================================
(AMZ)
725. Split Linked List in Parts

- Math & LinkedList
