=========================================================================================================
3. Longest Substring Without Repeating Characters

- Queue + Set O(n)

=========================================================================================================
4. Median of Two Sorted Arrays

- Binary Search

=========================================================================================================
10. Regular Expression Matching

- Recursion
- Backtracking
- DP

=========================================================================================================
11. Container With Most Water

- Brute Force O(n * n)
- Recursion O(n * n)
- Two point scan O(n) (https://leetcode.com/problems/container-with-most-water/discuss/6091/Easy-Concise-Java-O(N)-Solution-with-Proof-and-Explanation)

=========================================================================================================
23. Merge k Sorted Lists

- Divide & Conquer O(n * logn)
- Heap/Priority Queue O(n * logn)
- Recursion O(n * n)
- Sorting O(n * logn)

=========================================================================================================
32. Longest Valid Parentheses

- Stack O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack)
- Recursion O(2^n)
- DP O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14133/My-DP-O(n)-solution-without-using-stack)

=========================================================================================================
42. Trapping Rain Water (*)

- Recursion O(n)
- DP O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Two Pointers O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Stack O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)

=========================================================================================================
49. Group Anagrams

- Union Find O(n * n)
- HashTable/HashMap O(n)

=========================================================================================================
72. Edit Distance

- Recursion (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)
- DP (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)

=========================================================================================================
84. Largest Rectangle in Histogram (*)

- Brute Force
Scan from left to right to find the area for each Histogram.
Time: O(n * n)

- Binary Search Tree
We can think of the probelm is to solve that find the range of nodes that is larger than the current height
and calculate the area from the range. e.g., for node 3, height is 5, and the nodes is higher than node 3 are
node 4 and 5, thus the area is 5 * 2 = 10.
We can build a binary search tree storing node numbers, find a range of nodes that is larger than current node
and calculate the area and find the maximum.
Time: O (n * logn)

- Divide & Conquer (https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/)
We can use Divide and Conquer to solve this in O(n * Logn) time. The idea is to find the minimum value in the given array. Once we have index of the minimum value, the max area is maximum of following three values.
a) Maximum area in left side of minimum value (Not including the min value)
b) Maximum area in right side of minimum value (Not including the min value)
c) Number of bars multiplied by minimum value.
The areas in left and right of minimum value bar can be calculated recursively. If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). In worst case, we always have (n-1) elements in one side and 0 elements in other side and if the finding minimum takes O(n) time, we get the recurrence similar to worst case of Quick Sort.

- Stack (https://www.geeksforgeeks.org/largest-rectangle-under-histogram/)
We can use stack to calculate the area for each histogram in O(n).
We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.
1) Create an empty stack.
2) Start from first bar, and do following for every bar ‘hist[i]’ where ‘i’ varies from 0 to n-1.
……a) If stack is empty or hist[i] is higher than the bar at top of stack, then push ‘i’ to stack.
……b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).
3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.

=========================================================================================================
102. Binary Tree Level Order Traversal

- BFS
- Queue

=========================================================================================================
121. Best Time to Buy and Sell Stock

- Brute Force O(n * n)
- Recursion O(n * n)
- DP O(n)
- One time scan with Min and Max O(n)
- Sort + Two pointers O(n * logn)

=========================================================================================================
126. Word Ladder II (*)

- DFS
- BFS (Queue)
- Backtracking (DFS + Pruning)

=========================================================================================================
127. Word Ladder

- DFS
- BFS (Queue) (The best solution) (https://zxi.mytechroad.com/blog/searching/127-word-ladder/)
- Backtracking (DFS + Pruning)

=========================================================================================================
138. Copy List with Random Pointer

- Hash Table/Map (https://blog.csdn.net/liuchonge/article/details/74858192)
- Interweave (http://fisherlei.blogspot.com/2013/11/leetcode-copy-list-with-random-pointer.html)

=========================================================================================================
139. Word Break

- DFS + Trie
- Backtracking + Trie
- Recursion O(n * n)
- DP O(n * n)

=========================================================================================================
141. Linked List Cycle

- Set O(n)
- Two Pointers (Fast + Slow) O(n)

=========================================================================================================
146. LRU Cache (*)

- HashMap + Queue
- HashMap + Double Linked List (https://leetcode.com/problems/lru-cache/discuss/45911/Java-Hashtable-%2B-Double-linked-list-(with-a-touch-of-pseudo-nodes))
(https://www.cnblogs.com/yrbbest/p/4489577.html)

=========================================================================================================
155. Min Stack (*)

- Stack + Heap
- Pure Stack (https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack)
- Two Stacks (https://leetcode.com/problems/min-stack/discuss/49030/Simple-Java-solution-using-two-build-in-stacks)
- Pure Linked List (https://leetcode.com/problems/min-stack/discuss/49010/Clean-6ms-Java-solution)
- Stack + Linked List

=========================================================================================================
160. Intersection of Two Linked Lists (*)

- Set
- Get Linked List length first and run two pointers at the same position (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49792/Concise-JAVA-solution-O(1)-memory-O(n)-time)
- Two pointers (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!)

=========================================================================================================
167. Two Sum II - Input array is sorted

- Recursion O(n * n)
- Two Pointers O(n)
- Binary Search O(n * logn)

=========================================================================================================
189. Rotate Array (*)

- Reverse Array (https://leetcode.com/problems/rotate-array/discuss/54250/Easy-to-read-Java-solution)
- New Array (https://leetcode.com/problems/rotate-array/discuss/54289/My-three-way-to-solve-this-problem-the-first-way-is-interesting(JAVA))
- Replace 1 by 1 (https://leetcode.com/problems/rotate-array/discuss/54490/*Java*-O(1)-space-O(n)-time-with-detailed-explanations)

=========================================================================================================
211. Add and Search Word - Data structure design

- HashSet/HashMap
- Trie
- Array/List (Sorting & Backtracking)

=========================================================================================================
218. The Skyline Problem

- Divide & Conquer
- Heap (sweep line: https://zxi.mytechroad.com/blog/tree/leetcode-218-the-skyline-problem/)
- Tree, Segment Tree