=========================================================================================================
3. Longest Substring Without Repeating Characters

- Queue + Set O(n)

=========================================================================================================
4. Median of Two Sorted Arrays

- Binary Search

=========================================================================================================
10. Regular Expression Matching

- Recursion
- Backtracking
- DP

=========================================================================================================
11. Container With Most Water

- Brute Force O(n * n)
- Recursion O(n * n)
- Two point scan O(n) (https://leetcode.com/problems/container-with-most-water/discuss/6091/Easy-Concise-Java-O(N)-Solution-with-Proof-and-Explanation)

=========================================================================================================
23. Merge k Sorted Lists

- Divide & Conquer O(n * logn)
- Heap/Priority Queue O(n * logn)
- Recursion O(n * n)
- Sorting O(n * logn)

=========================================================================================================
32. Longest Valid Parentheses (*)

- Stack O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14126/My-O(n)-solution-using-a-stack)
- Recursion O(2^n)
- DP O(n) (https://leetcode.com/problems/longest-valid-parentheses/discuss/14133/My-DP-O(n)-solution-without-using-stack)

=========================================================================================================
42. Trapping Rain Water (*)

- Recursion O(n)
- DP O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Two Pointers O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)
- Stack O(n) (http://www.cnblogs.com/grandyang/p/4402392.html)

=========================================================================================================
49. Group Anagrams

- Union Find O(n * n)
- HashTable/HashMap O(n)

=========================================================================================================
72. Edit Distance

- Recursion (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)
- DP (http://zxi.mytechroad.com/blog/dynamic-programming/leetcode-72-edit-distance/)

=========================================================================================================
84. Largest Rectangle in Histogram (*)

- Brute Force
Scan from left to right to find the area for each Histogram.
Time: O(n * n)

- Binary Search Tree
We can think of the probelm is to solve that find the range of nodes that is larger than the current height
and calculate the area from the range. e.g., for node 3, height is 5, and the nodes is higher than node 3 are
node 4 and 5, thus the area is 5 * 2 = 10.
We can build a binary search tree storing node numbers, find a range of nodes that is larger than current node
and calculate the area and find the maximum.
Time: O (n * logn)

- Divide & Conquer (https://www.geeksforgeeks.org/largest-rectangular-area-in-a-histogram-set-1/)
We can use Divide and Conquer to solve this in O(n * Logn) time. The idea is to find the minimum value in the given array. Once we have index of the minimum value, the max area is maximum of following three values.
a) Maximum area in left side of minimum value (Not including the min value)
b) Maximum area in right side of minimum value (Not including the min value)
c) Number of bars multiplied by minimum value.
The areas in left and right of minimum value bar can be calculated recursively. If we use linear search to find the minimum value, then the worst case time complexity of this algorithm becomes O(n^2). In worst case, we always have (n-1) elements in one side and 0 elements in other side and if the finding minimum takes O(n) time, we get the recurrence similar to worst case of Quick Sort.

- Stack (https://www.geeksforgeeks.org/largest-rectangle-under-histogram/)
We can use stack to calculate the area for each histogram in O(n).
We traverse all bars from left to right, maintain a stack of bars. Every bar is pushed to stack once. A bar is popped from stack when a bar of smaller height is seen. When a bar is popped, we calculate the area with the popped bar as smallest bar. How do we get left and right indexes of the popped bar – the current index tells us the ‘right index’ and index of previous item in stack is the ‘left index’. Following is the complete algorithm.
1) Create an empty stack.
2) Start from first bar, and do following for every bar ‘hist[i]’ where ‘i’ varies from 0 to n-1.
……a) If stack is empty or hist[i] is higher than the bar at top of stack, then push ‘i’ to stack.
……b) If this bar is smaller than the top of stack, then keep removing the top of stack while top of the stack is greater. Let the removed bar be hist[tp]. Calculate area of rectangle with hist[tp] as smallest bar. For hist[tp], the ‘left index’ is previous (previous to tp) item in stack and ‘right index’ is ‘i’ (current index).
3) If the stack is not empty, then one by one remove all bars from stack and do step 2.b for every removed bar.

=========================================================================================================
102. Binary Tree Level Order Traversal

- BFS
- Queue

=========================================================================================================
121. Best Time to Buy and Sell Stock

- Brute Force O(n * n)
- Recursion O(n * n)
- DP O(n)
- One time scan with Min and Max O(n)
- Sort + Two pointers O(n * logn)

=========================================================================================================
126. Word Ladder II (*)

- DFS
- BFS (Queue)
- Backtracking (DFS + Pruning)

=========================================================================================================
127. Word Ladder

- DFS
- BFS (Queue) (The best solution) (https://zxi.mytechroad.com/blog/searching/127-word-ladder/)
- Backtracking (DFS + Pruning)

=========================================================================================================
138. Copy List with Random Pointer

- Hash Table/Map (https://blog.csdn.net/liuchonge/article/details/74858192)
- Interweave (http://fisherlei.blogspot.com/2013/11/leetcode-copy-list-with-random-pointer.html)

=========================================================================================================
139. Word Break

- DFS + Trie
- Backtracking + Trie
- Recursion O(n * n)
- DP O(n * n)

=========================================================================================================
141. Linked List Cycle

- Set O(n)
- Two Pointers (Fast + Slow) O(n)

=========================================================================================================
146. LRU Cache (*)

- HashMap + Queue
- HashMap + Double Linked List (https://leetcode.com/problems/lru-cache/discuss/45911/Java-Hashtable-%2B-Double-linked-list-(with-a-touch-of-pseudo-nodes))
(https://www.cnblogs.com/yrbbest/p/4489577.html)

=========================================================================================================
155. Min Stack (*)

- Stack + Heap
- Pure Stack (https://leetcode.com/problems/min-stack/discuss/49014/Java-accepted-solution-using-one-stack)
- Two Stacks (https://leetcode.com/problems/min-stack/discuss/49030/Simple-Java-solution-using-two-build-in-stacks)
- Pure Linked List (https://leetcode.com/problems/min-stack/discuss/49010/Clean-6ms-Java-solution)
- Stack + Linked List

=========================================================================================================
160. Intersection of Two Linked Lists (*)

- Set
- Get Linked List length first and run two pointers at the same position (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49792/Concise-JAVA-solution-O(1)-memory-O(n)-time)
- Two pointers (https://leetcode.com/problems/intersection-of-two-linked-lists/discuss/49785/Java-solution-without-knowing-the-difference-in-len!)

=========================================================================================================
167. Two Sum II - Input array is sorted

- Recursion O(n * n)
- Two Pointers O(n)
- Binary Search O(n * logn)

=========================================================================================================
189. Rotate Array (*)

- Reverse Array (https://leetcode.com/problems/rotate-array/discuss/54250/Easy-to-read-Java-solution)
- New Array (https://leetcode.com/problems/rotate-array/discuss/54289/My-three-way-to-solve-this-problem-the-first-way-is-interesting(JAVA))
- Replace 1 by 1 (https://leetcode.com/problems/rotate-array/discuss/54490/*Java*-O(1)-space-O(n)-time-with-detailed-explanations)

=========================================================================================================
199. Binary Tree Right Side View (*)

- BFS (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56076/Reverse-Level-Order-Traversal-java)
- DFS (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56167/DFS-solution-better-than-90-solutions!)
- Recursion (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56012/My-simple-accepted-solution(JAVA))
- Divide & Conquer (https://leetcode.com/problems/binary-tree-right-side-view/discuss/56062/Java-Solution-using-Divide-and-Conquer)

=========================================================================================================
200. Number of Islands (*)

- DFS O(n * m) (https://leetcode.com/problems/number-of-islands/discuss/56359/Very-concise-Java-AC-solution)
- BFS O(n * m) (https://leetcode.com/problems/number-of-islands/discuss/56338/Java-DFS-and-BFS-solution)
- Union Find O(n * m * log(n * m)) (https://leetcode.com/problems/number-of-islands/discuss/56354/1D-Union-Find-Java-solution-easily-generalized-to-other-problems)
- Recursion (by row/column) O(n * m)
- Divide & Conquer O(n * m)

=========================================================================================================
204. Count Primes

- Math (https://leetcode.com/problems/count-primes/discuss/57588/My-simple-Java-solution)

=========================================================================================================
206. Reverse Linked List

- Recursion (https://leetcode.com/problems/reverse-linked-list/discuss/58156/My-Java-recursive-solution)
- Divide & Conquer
- Linked List operation (in-place) (https://leetcode.com/problems/reverse-linked-list/discuss/58125/In-place-iterative-and-recursive-Java-solution)

=========================================================================================================
211. Add and Search Word - Data structure design (*)

- HashSet/HashMap
- Trie
- Array/List (Sorting & Backtracking)

=========================================================================================================
215. Kth Largest Element in an Array (*)

- Sort O(n * logn) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained)
- Priority Queue O(n * logk) /Heap O(n * logn) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60294/Solution-explained)
- Quick Select O(n * logn) (https://en.wikipedia.org/wiki/Quickselect) (https://leetcode.com/problems/kth-largest-element-in-an-array/discuss/60312/AC-Clean-QuickSelect-Java-solution-avg.-O(n)-time)
- Recursion O(n * n)

=========================================================================================================
218. The Skyline Problem (*)

- Divide & Conquer
- Heap (sweep line: https://zxi.mytechroad.com/blog/tree/leetcode-218-the-skyline-problem/)
- Tree, Segment Tree

=========================================================================================================
234. Palindrome Linked List

- Stack
- Array
- Recursion
- Two Pointers (https://leetcode.com/problems/palindrome-linked-list/discuss/64501/Java-easy-to-understand)

=========================================================================================================
235. Lowest Common Ancestor of a Binary Search Tree

- Iteratvie O(logn)
- Recursion

=========================================================================================================
236. Lowest Common Ancestor of a Binary Tree

- DFS/BFS to find the path, then find common ancester (https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65335/Java-iterative-and-recursive-solutions.)
- Recursion (https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/discuss/65225/4-lines-C%2B%2BJavaPythonRuby)

=========================================================================================================
238. Product of Array Except Self (*)

- Math (https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space)
(https://leetcode.com/problems/product-of-array-except-self/discuss/65632/My-solution-beats-100-java-solutions)
(https://leetcode.com/problems/product-of-array-except-self/discuss/65622/Simple-Java-solution-in-O(n)-without-extra-space/265861)

=========================================================================================================
239. Sliding Window Maximum

- Heap O(n * logk) (https://leetcode.com/problems/sliding-window-maximum/discuss/65936/My-Java-Solution-Using-PriorityQueue)
- Recursion O(n * k)
- Two Pointers, record the highest and the second highest point O(n)
- Deque O(n) (https://leetcode.com/problems/sliding-window-maximum/discuss/65884/Java-O(n)-solution-using-deque-with-explanation)
- Math O(n) (https://leetcode.com/problems/sliding-window-maximum/discuss/65881/O(n)-solution-in-Java-with-two-simple-pass-in-the-array)

=========================================================================================================
240. Search a 2D Matrix II

- DFS/Recursion O(m * n)
- Iterative O(m * n)
- Divide & Conquer (https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66147/*Java*-an-easy-to-understand-divide-and-conquer-method)
- Two Pointers/BST O(m + n) (https://leetcode.com/problems/search-a-2d-matrix-ii/discuss/66140/My-concise-O(m%2Bn)-Java-solution)

=========================================================================================================
242. Valid Anagram

- HashMap/HashTable O(n) (https://leetcode.com/problems/valid-anagram/discuss/66533/Java-solution-HashMap-Unicode-Follow-up)
- Sort O(n * logn) (https://leetcode.com/problems/valid-anagram/discuss/66651/Java-solution-using-sort)
- Array O(n) (https://leetcode.com/problems/valid-anagram/discuss/66484/Accepted-Java-O(n)-solution-in-5-lines)

=========================================================================================================
297. Serialize and Deserialize Binary Tree (*)

- Serialize as array - [1,2,3,null,null,4,5]
- Serialize as JSON with ID - [id:1,val:1,left:2,right:3],[id:2,val:2],[id:3,left:4,right:5],...
- Serialize as String - 1{2}{3{4}{5}}/1(2)(3(4(5))
- Pre-order & Queue (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74253/Easy-to-understand-Java-Solution)
- BFS & Queue (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74264/Short-and-straight-forward-BFS-Java-code-with-a-queue)
- DFS & BFS (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74260/Recursive-DFS-Iterative-DFS-and-BFS)
- Recusion (https://leetcode.com/problems/serialize-and-deserialize-binary-tree/discuss/74417/Short-and-clear-recursive-Java-solution)

=========================================================================================================
355. Design Twitter (*)

- HashMap/HashTable + Linked List
- OO Design + HashTable/HashMap + Heap + Linked List + HashSet/Set (https://leetcode.com/problems/design-twitter/discuss/82825/Java-OO-Design-with-most-efficient-function-getNewsFeed)
- Map + Heap (https://leetcode.com/problems/design-twitter/discuss/82837/Java-Solutions-with-Two-Maps-and-PriorityQueue)
- OO Design (https://leetcode.com/problems/design-twitter/discuss/82935/Java-OOD-solution-with-detailed-explanation)

=========================================================================================================
380. Insert Delete GetRandom O(1) (*)

- HashSet, HashMap, Array
- HashMap, List/Array (https://leetcode.com/problems/insert-delete-getrandom-o1/discuss/85401/Java-solution-using-a-HashMap-and-an-ArrayList-along-with-a-follow-up.-(131-ms))

=========================================================================================================
387. First Unique Character in a String

- HashMap O(n)
- Divide & Conquer O(n * logn)
- Recursion O(n * n)

=========================================================================================================
396. Rotate Function

- Brute Force to list all possible results O(n * n)
- Math O(n) (https://leetcode.com/problems/rotate-function/discuss/87853/Java-O(n)-solution-with-explanation)

=========================================================================================================
414. Third Maximum Number

- Heap/Priority Queue O(n * logn) (https://leetcode.com/problems/third-maximum-number/discuss/90190/Java-PriorityQueue-O(n)-%2B-O(1))
- Sorting O(n * logn)
- Fixed length array/Double Linked List O(n) (https://leetcode.com/problems/third-maximum-number/discuss/90202/Java-neat-and-easy-understand-solution-O(n)-time-O(1)-space)

=========================================================================================================
438. Find All Anagrams in a String

- HashMap to build char-count map O(n) (Sliding Window Solution)

=========================================================================================================
449. Serialize and Deserialize BST

- Recusrion: use parentheses e.g. 78(13(5)(45))(105) (Generic: applicable to all types of trees)
- BFS: 78, 13, 105, 5, 45, null, null (Generic: applicable to all types of trees)

=========================================================================================================
451. Sort Characters By Frequency

- HashMap + Sort O(n)
- Array + Sort O(n) (https://leetcode.com/problems/sort-characters-by-frequency/discuss/93521/Super-simple-O(n)-Bucket-Sort-based-Java-solution-(11-ms).-No-fancy-Data-structure-needed.-Beats-96.)
- HashMap + Heap/Priority Queue O(n) (https://leetcode.com/problems/sort-characters-by-frequency/discuss/93420/Java-O(n)-Bucket-Sort-Solution-O(nlogm)-PriorityQueue-Solution-easy-to-understand)

=========================================================================================================
459. Repeated Substring Pattern (*)

- Brute Force (iterate through all possible substrings, with pruning) O(n * n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94352/Java-Simple-Solution-with-Explanation)
- Two cursor O(n * n)
- Math/Smart Solution O(n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94334/Easy-python-solution-with-explaination/241011)
- KMP O(n) (https://leetcode.com/problems/repeated-substring-pattern/discuss/94340/Java-and-O(n)/113294)

=========================================================================================================
460. LFU Cache (*)

- Heap/Priority Queue + HashMap O(logn)
- 3 HashMap + LinkedHashSet O(1) (https://leetcode.com/problems/lfu-cache/discuss/94521/JAVA-O(1)-very-easy-solution-using-3-HashMaps-and-LinkedHashSet)
- HashMap + DoubleLinkedList + LinkedHashSet O(1) (https://leetcode.com/problems/lfu-cache/discuss/94515/Java-O(1)-Accept-Solution-Using-HashMap-DoubleLinkedList-and-LinkedHashSet)
(https://leetcode.com/problems/lfu-cache/discuss/94547/Java-O(1)-Solution-Using-Two-HashMap-and-One-DoubleLinkedList)
- Reb-Black Tree + HashMap O(logn) (https://leetcode.com/problems/lfu-cache/discuss/94657/Java-solutions-of-three-different-ways.-PriorityQueue-%3A-O(capacity)-TreeMap-%3A-O(log(capacity))-DoubleLinkedList-%3A-O(1))

=========================================================================================================
508. Most Frequent Subtree Sum

- DFS + Heap/Priority Queue O(n * logn) (https://leetcode.com/problems/most-frequent-subtree-sum/discuss/98675/JavaC%2B%2BPython-DFS-Find-Subtree-Sum)

=========================================================================================================
515. Find Largest Value in Each Tree Row

- BFS + Queue O(n) (https://leetcode.com/problems/find-largest-value-in-each-tree-row/discuss/98976/Java-BFS)
- Traverse trhough Tree/DFS (pre-order, in-order, post-order) O(n) (https://leetcode.com/problems/find-largest-value-in-each-tree-row/discuss/98971/9ms-JAVA-DFS-solution)

=========================================================================================================
516. Longest Palindromic Subsequence

- Brute Force (List all substring possibilities and check) O(n * n)
- Recusion/DP O(n * n) (https://leetcode.com/problems/longest-palindromic-subsequence/discuss/99101/Straight-forward-Java-DP-solution)

=========================================================================================================
517. Super Washing Machines (*)

- Math (https://blog.csdn.net/TstsUgeg/article/details/62427718) (https://leetcode.com/problems/super-washing-machines/discuss/99185/Super-Short-and-Easy-Java-O(n)-Solution)

=========================================================================================================
529. Minesweeper (*)

- BFS/DFS to find adjacent blank square (https://leetcode.com/problems/minesweeper/discuss/99826/Java-Solution-DFS-%2B-BFS)
- Union-Find (Grouping) to find adjacent blank square

=========================================================================================================
532. K-diff Pairs in an Array

- HashSet/HashMap (Brute Force) O(n) (https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/355150/Java-time-and-space-O(n)-solution-by-HaspMap)
- Recursion O(n) (f(n) = f(n - 1) + exist(n +/- k))
- Sorting (n * logn)
- Sorting + Two Pointers (n * logn) (https://leetcode.com/problems/k-diff-pairs-in-an-array/discuss/100104/Two-pointer-Approach)

=========================================================================================================
535. Encode and Decode TinyURL (*)

- HashMap - Random String (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100268/Two-solutions-and-thoughts)
- HashMap - Hashcode String (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100270/Three-different-approaches-in-java)
(https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/254145/Java-Solutions)
- HashMap/Array - Use Index/Counter (https://leetcode.com/problems/encode-and-decode-tinyurl/discuss/100276/Easy-solution-in-java-5-line-code)

=========================================================================================================
537. Complex Number Multiplication

- String & Math (https://leetcode.com/problems/complex-number-multiplication/discuss/100430/Java-3-liner)

=========================================================================================================
538. Convert BST to Greater Tree

- DFS/Recursion/Traverse (Traverse in decreasing order, sum up accumulatively) O(n) (https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/100506/Java-Recursive-O(n)-time)
- Iterative using Stack O(n) (https://leetcode.com/problems/convert-bst-to-greater-tree/discuss/100516/Java-Three-O(n)-Methods%3A-Recursive-Iterative-and-Morris-Traversal)