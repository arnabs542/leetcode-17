================================================================================
Reference:

- https://www.programcreek.com/2013/08/leetcode-problem-classification/
- https://www.programering.com/a/MjN5UjNwATM.html (by Chapter)
- https://blog.csdn.net/zhuiyizhuiyi/article/details/41112487
- http://teisei.github.io/algorithm/leetcode/2016/05/31/Leetcode-Classification/
- http://westpavilion.blogspot.com/2014/01/leetcode-classification.html
- http://fisherlei.blogspot.com/2013/01/leetcode-subsets-ii.html (See labels)
- https://blog.csdn.net/qq508618087/article/details/49528235 (See category on right hand side)

By company:
- http://www.learn4master.com/interview-questions/leetcode/leetcode-problems-classified-by-company

================================================================================
Problem Classification:

- Search
-- DFS
-- BFS
-- Binary Search
-- Two Pointers
-- Back Tracking
-- Greedy Algorithm
-- Brute-force

- Recursion
-- DP
-- Recursion

- Data Structure
-- Stack
-- HashMap
-- HashSet
-- Heap
-- Graph
-- Queue
-- LinkedList
-- Tree

- Sort
-- Bucket Sort
-- Quick Sort
-- Merge Sort (Divide & Conquer)

- Divide & Conquer
-- Merge Sort

- Bit Manipulation

- Math

================================================================================
Common Strategies:

- Divide & Conquer: solve a big problem by solving small problems (Binary Search)
- Recursion: solve a problem by solving sub-problems
- Sorting: solve some digit comparasion related problem would be easier if everythinkg
is already sorted
- Space & Time trade-off: sometimes we can use more space to fasten the solution
(HashTable to remember result to avoid computing same values twice, Array)
- Data Structure: proper data structure would be very helpful when solve some specific
problems (HashTable for quick lookup, Tree/Balanced Tree is good for indexing, Queue
and Stack good for dealing with sequence)
